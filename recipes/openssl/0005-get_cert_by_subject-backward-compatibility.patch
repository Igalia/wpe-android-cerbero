From aadeb66867fbd4a6ef6f6b6dda6eb53ba08eb419 Mon Sep 17 00:00:00 2001
From: Bruno de Lacheisserie <bruno.de.lacheisserie@gmail.com>
Date: Fri, 29 Mar 2024 01:21:42 +0100
Subject: [PATCH 1/6] get_cert_by_subject : backward compatibility

Fallback to MD5 name hash if no certificate found using SHA1 hash

fixes #13565 #15154
---
 crypto/x509/by_dir.c | 296 ++++++++++++++++++++++---------------------
 1 file changed, 154 insertions(+), 142 deletions(-)

Upstream: https://github.com/openssl/openssl/pull/24002

diff --git a/crypto/x509/by_dir.c b/crypto/x509/by_dir.c
index 1d401d0420884..b81c7b637a649 100644
--- a/crypto/x509/by_dir.c
+++ b/crypto/x509/by_dir.c
@@ -229,7 +229,8 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
         X509_CRL crl;
     } data;
     int ok = 0;
-    int i, j, k;
+    int i, j, k, l;
+    unsigned long hash[2];
     unsigned long h;
     BUF_MEM *b = NULL;
     X509_OBJECT stmp, *tmp;
@@ -257,165 +258,176 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
     }
 
     ctx = (BY_DIR *)xl->method_data;
-    h = X509_NAME_hash_ex(name, libctx, propq, &i);
-    if (i == 0)
-        goto finish;
-    for (i = 0; i < sk_BY_DIR_ENTRY_num(ctx->dirs); i++) {
-        BY_DIR_ENTRY *ent;
-        int idx;
-        BY_DIR_HASH htmp, *hent;
-
-        ent = sk_BY_DIR_ENTRY_value(ctx->dirs, i);
-        j = strlen(ent->dir) + 1 + 8 + 6 + 1 + 1;
-        if (!BUF_MEM_grow(b, j)) {
-            ERR_raise(ERR_LIB_X509, ERR_R_BUF_LIB);
-            goto finish;
+
+    hash[0] = X509_NAME_hash_ex(name, libctx, propq, &l); /* SHA1 name hash */
+    if (l == 0) {
+        hash[0] = 0;
+    }
+    hash[1] = X509_NAME_hash_old(name); /* MD5 name hash */
+
+    for (l = 0; l < 2; ++l) {
+        h = hash[l];
+        if (h == 0) {
+            continue; /* skip invalid hash */
         }
-        if (type == X509_LU_CRL && ent->hashes) {
-            htmp.hash = h;
-            if (!CRYPTO_THREAD_read_lock(ctx->lock))
+
+        for (i = 0; i < sk_BY_DIR_ENTRY_num(ctx->dirs); i++) {
+            BY_DIR_ENTRY *ent;
+            int idx;
+            BY_DIR_HASH htmp, *hent;
+
+            ent = sk_BY_DIR_ENTRY_value(ctx->dirs, i);
+            j = strlen(ent->dir) + 1 + 8 + 6 + 1 + 1;
+            if (!BUF_MEM_grow(b, j)) {
+                ERR_raise(ERR_LIB_X509, ERR_R_BUF_LIB);
                 goto finish;
-            idx = sk_BY_DIR_HASH_find(ent->hashes, &htmp);
-            if (idx >= 0) {
-                hent = sk_BY_DIR_HASH_value(ent->hashes, idx);
-                k = hent->suffix;
-            } else {
-                hent = NULL;
-                k = 0;
             }
-            CRYPTO_THREAD_unlock(ctx->lock);
-        } else {
-            k = 0;
-            hent = NULL;
-        }
-        for (;;) {
-            char c = '/';
-
-#ifdef OPENSSL_SYS_VMS
-            c = ent->dir[strlen(ent->dir) - 1];
-            if (c != ':' && c != '>' && c != ']') {
-                /*
-                 * If no separator is present, we assume the directory
-                 * specifier is a logical name, and add a colon.  We really
-                 * should use better VMS routines for merging things like
-                 * this, but this will do for now... -- Richard Levitte
-                 */
-                c = ':';
+            if (type == X509_LU_CRL && ent->hashes) {
+                htmp.hash = h;
+                if (!CRYPTO_THREAD_read_lock(ctx->lock))
+                    goto finish;
+                idx = sk_BY_DIR_HASH_find(ent->hashes, &htmp);
+                if (idx >= 0) {
+                    hent = sk_BY_DIR_HASH_value(ent->hashes, idx);
+                    k = hent->suffix;
+                } else {
+                    hent = NULL;
+                    k = 0;
+                }
+                CRYPTO_THREAD_unlock(ctx->lock);
             } else {
-                c = '\0';
+                k = 0;
+                hent = NULL;
             }
+            for (;;) {
+                char c = '/';
+
+    #ifdef OPENSSL_SYS_VMS
+                c = ent->dir[strlen(ent->dir) - 1];
+                if (c != ':' && c != '>' && c != ']') {
+                    /*
+                    * If no separator is present, we assume the directory
+                    * specifier is a logical name, and add a colon.  We really
+                    * should use better VMS routines for merging things like
+                    * this, but this will do for now... -- Richard Levitte
+                    */
+                    c = ':';
+                } else {
+                    c = '\0';
+                }
 
-            if (c == '\0') {
-                /*
-                 * This is special.  When c == '\0', no directory separator
-                 * should be added.
-                 */
-                BIO_snprintf(b->data, b->max,
-                             "%s%08lx.%s%d", ent->dir, h, postfix, k);
-            } else
-#endif
-            {
-                BIO_snprintf(b->data, b->max,
-                             "%s%c%08lx.%s%d", ent->dir, c, h, postfix, k);
-            }
-#ifndef OPENSSL_NO_POSIX_IO
-# ifdef _WIN32
-#  define stat _stat
-# endif
-            {
-                struct stat st;
-                if (stat(b->data, &st) < 0)
-                    break;
-            }
-#endif
-            /* found one. */
-            if (type == X509_LU_X509) {
-                if ((X509_load_cert_file_ex(xl, b->data, ent->dir_type, libctx,
-                                            propq)) == 0)
-                    break;
-            } else if (type == X509_LU_CRL) {
-                if ((X509_load_crl_file(xl, b->data, ent->dir_type)) == 0)
-                    break;
+                if (c == '\0') {
+                    /*
+                    * This is special.  When c == '\0', no directory separator
+                    * should be added.
+                    */
+                    BIO_snprintf(b->data, b->max,
+                                "%s%08lx.%s%d", ent->dir, h, postfix, k);
+                } else
+    #endif
+                {
+                    BIO_snprintf(b->data, b->max,
+                                "%s%c%08lx.%s%d", ent->dir, c, h, postfix, k);
+                }
+    #ifndef OPENSSL_NO_POSIX_IO
+    # ifdef _WIN32
+    #  define stat _stat
+    # endif
+                {
+                    struct stat st;
+                    if (stat(b->data, &st) < 0)
+                        break;
+                }
+    #endif
+                /* found one. */
+                if (type == X509_LU_X509) {
+                    if ((X509_load_cert_file_ex(xl, b->data, ent->dir_type, libctx,
+                                                propq)) == 0)
+                        break;
+                } else if (type == X509_LU_CRL) {
+                    if ((X509_load_crl_file(xl, b->data, ent->dir_type)) == 0)
+                        break;
+                }
+                /* else case will caught higher up */
+                k++;
             }
-            /* else case will caught higher up */
-            k++;
-        }
 
-        /*
-         * we have added it to the cache so now pull it out again
-         *
-         * Note: quadratic time find here since the objects won't generally be
-         *       sorted and sorting the would result in O(n^2 log n) complexity.
-         */
-        if (k > 0) {
-            if (!X509_STORE_lock(xl->store_ctx))
-                goto finish;
-            j = sk_X509_OBJECT_find(xl->store_ctx->objs, &stmp);
-            tmp = sk_X509_OBJECT_value(xl->store_ctx->objs, j);
-            X509_STORE_unlock(xl->store_ctx);
-        } else {
-            tmp = NULL;
-        }
-        /*
-         * If a CRL, update the last file suffix added for this.
-         * We don't need to add an entry if k is 0 as this is the initial value.
-         * This avoids the need for a write lock and sort operation in the
-         * simple case where no CRL is present for a hash.
-         */
-        if (type == X509_LU_CRL && k > 0) {
-            if (!CRYPTO_THREAD_write_lock(ctx->lock))
-                goto finish;
             /*
-             * Look for entry again in case another thread added an entry
-             * first.
-             */
-            if (hent == NULL) {
-                htmp.hash = h;
-                idx = sk_BY_DIR_HASH_find(ent->hashes, &htmp);
-                hent = sk_BY_DIR_HASH_value(ent->hashes, idx);
+            * we have added it to the cache so now pull it out again
+            *
+            * Note: quadratic time find here since the objects won't generally be
+            *       sorted and sorting the would result in O(n^2 log n) complexity.
+            */
+            if (k > 0) {
+                if (!X509_STORE_lock(xl->store_ctx))
+                    goto finish;
+                j = sk_X509_OBJECT_find(xl->store_ctx->objs, &stmp);
+                tmp = sk_X509_OBJECT_value(xl->store_ctx->objs, j);
+                X509_STORE_unlock(xl->store_ctx);
+            } else {
+                tmp = NULL;
             }
-            if (hent == NULL) {
-                hent = OPENSSL_malloc(sizeof(*hent));
-                if (hent == NULL) {
-                    CRYPTO_THREAD_unlock(ctx->lock);
-                    ok = 0;
+            /*
+            * If a CRL, update the last file suffix added for this.
+            * We don't need to add an entry if k is 0 as this is the initial value.
+            * This avoids the need for a write lock and sort operation in the
+            * simple case where no CRL is present for a hash.
+            */
+            if (type == X509_LU_CRL && k > 0) {
+                if (!CRYPTO_THREAD_write_lock(ctx->lock))
                     goto finish;
+                /*
+                * Look for entry again in case another thread added an entry
+                * first.
+                */
+                if (hent == NULL) {
+                    htmp.hash = h;
+                    idx = sk_BY_DIR_HASH_find(ent->hashes, &htmp);
+                    hent = sk_BY_DIR_HASH_value(ent->hashes, idx);
                 }
-                hent->hash = h;
-                hent->suffix = k;
-                if (!sk_BY_DIR_HASH_push(ent->hashes, hent)) {
-                    CRYPTO_THREAD_unlock(ctx->lock);
-                    OPENSSL_free(hent);
-                    ERR_raise(ERR_LIB_X509, ERR_R_CRYPTO_LIB);
-                    ok = 0;
-                    goto finish;
+                if (hent == NULL) {
+                    hent = OPENSSL_malloc(sizeof(*hent));
+                    if (hent == NULL) {
+                        CRYPTO_THREAD_unlock(ctx->lock);
+                        ok = 0;
+                        goto finish;
+                    }
+                    hent->hash = h;
+                    hent->suffix = k;
+                    if (!sk_BY_DIR_HASH_push(ent->hashes, hent)) {
+                        CRYPTO_THREAD_unlock(ctx->lock);
+                        OPENSSL_free(hent);
+                        ERR_raise(ERR_LIB_X509, ERR_R_CRYPTO_LIB);
+                        ok = 0;
+                        goto finish;
+                    }
+
+                    /*
+                    * Ensure stack is sorted so that subsequent sk_BY_DIR_HASH_find
+                    * will not mutate the stack and therefore require a write lock.
+                    */
+                    sk_BY_DIR_HASH_sort(ent->hashes);
+                } else if (hent->suffix < k) {
+                    hent->suffix = k;
                 }
 
-                /*
-                 * Ensure stack is sorted so that subsequent sk_BY_DIR_HASH_find
-                 * will not mutate the stack and therefore require a write lock.
-                 */
-                sk_BY_DIR_HASH_sort(ent->hashes);
-            } else if (hent->suffix < k) {
-                hent->suffix = k;
-            }
-
-            CRYPTO_THREAD_unlock(ctx->lock);
+                CRYPTO_THREAD_unlock(ctx->lock);
 
-        }
+            }
 
-        if (tmp != NULL) {
-            ok = 1;
-            ret->type = tmp->type;
-            memcpy(&ret->data, &tmp->data, sizeof(ret->data));
+            if (tmp != NULL) {
+                ok = 1;
+                ret->type = tmp->type;
+                memcpy(&ret->data, &tmp->data, sizeof(ret->data));
 
-            /*
-             * Clear any errors that might have been raised processing empty
-             * or malformed files.
-             */
-            ERR_clear_error();
+                /*
+                * Clear any errors that might have been raised processing empty
+                * or malformed files.
+                */
+                ERR_clear_error();
 
-            goto finish;
+                goto finish;
+            }
         }
     }
  finish:

From 498b51d9322320bce430184c473573158cf0c4f8 Mon Sep 17 00:00:00 2001
From: Bruno de Lacheisserie <bruno.de.lacheisserie@gmail.com>
Date: Tue, 16 Apr 2024 14:26:30 +0200
Subject: [PATCH 2/6] do not use `X509_NAME_hash_old(...)` if `OPENSSL_NO_MD5`
 is defined

---
 crypto/x509/by_dir.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/crypto/x509/by_dir.c b/crypto/x509/by_dir.c
index b81c7b637a649..e9ff1951ca6da 100644
--- a/crypto/x509/by_dir.c
+++ b/crypto/x509/by_dir.c
@@ -263,7 +263,11 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
     if (l == 0) {
         hash[0] = 0;
     }
+#ifndef OPENSSL_NO_MD5    
     hash[1] = X509_NAME_hash_old(name); /* MD5 name hash */
+#else
+    hash[1] = 0;
+#endif
 
     for (l = 0; l < 2; ++l) {
         h = hash[l];

From b742beac8a9cd8e30ffeab72dd3525159c6eef3e Mon Sep 17 00:00:00 2001
From: Bruno de Lacheisserie <bruno.de.lacheisserie@gmail.com>
Date: Sun, 2 Jun 2024 14:36:17 +0200
Subject: [PATCH 3/6] Add a test of the X509_STORE / X509_LOOKUP API for MD5
 hash

---
 test/recipes/60-test_x509_store_old.t | 53 +++++++++++++++++++++++++++
 1 file changed, 53 insertions(+)
 create mode 100644 test/recipes/60-test_x509_store_old.t

diff --git a/test/recipes/60-test_x509_store_old.t b/test/recipes/60-test_x509_store_old.t
new file mode 100644
index 0000000000000..6a00c9a448333
--- /dev/null
+++ b/test/recipes/60-test_x509_store_old.t
@@ -0,0 +1,53 @@
+#! /usr/bin/env perl
+# Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the Apache License 2.0 (the "License").  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# https://www.openssl.org/source/license.html
+
+
+use strict;
+use warnings;
+
+use File::Copy;
+use File::Spec::Functions qw/:DEFAULT canonpath/;
+use OpenSSL::Test qw/:DEFAULT srctop_file/;
+
+setup("test_x509_store_old");
+
+#If "openssl rehash -help" fails it's most likely because we're on a platform
+#that doesn't support the rehash command (e.g. Windows)
+plan skip_all => "test_rehash is not available on this platform"
+    unless run(app(["openssl", "rehash", "-help"]));
+
+# We use 'openssl verify' for these tests, as it contains everything
+# we need to conduct these tests.  The tests here are a subset of the
+# ones found in 25-test_verify.t
+
+sub verify {
+    my ($cert, $purpose, $trustedpath, $untrusted, @opts) = @_;
+    my @args = qw(openssl verify -auth_level 1 -purpose);
+    my @path = qw(test certs);
+    push(@args, "$purpose", @opts);
+    push(@args, "-CApath", $trustedpath);
+    for (@$untrusted) { push(@args, "-untrusted", srctop_file(@path, "$_.pem")) }
+    push(@args, srctop_file(@path, "$cert.pem"));
+    run(app([@args]));
+}
+
+plan tests => 3;
+
+indir "60-test_x509_store_old" => sub {
+    for (("root-cert")) {
+        copy(srctop_file("test", "certs", "$_.pem"), curdir());
+    }
+    ok(run(app([qw(openssl rehash -old), curdir()])), "Rehashing");
+
+    # Canonical success
+    ok(verify("ee-cert", "sslserver", curdir(), ["ca-cert"], "-show_chain"),
+       "verify ee-cert");
+
+    # Failure because root cert not present in CApath
+    ok(!verify("ca-root2", "any", curdir(), [], "-show_chain"));
+}, create => 1, cleanup => 1;

From ef74616d2ea2cafcfe6c9cb04e00b69b0f6e8c6c Mon Sep 17 00:00:00 2001
From: Bruno de Lacheisserie <bruno.de.lacheisserie@gmail.com>
Date: Mon, 3 Jun 2024 12:32:56 +0200
Subject: [PATCH 4/6] fix comment indentation

---
 crypto/x509/by_dir.c | 55 ++++++++++++++++++++++----------------------
 1 file changed, 28 insertions(+), 27 deletions(-)

diff --git a/crypto/x509/by_dir.c b/crypto/x509/by_dir.c
index e9ff1951ca6da..53debd2dabfbb 100644
--- a/crypto/x509/by_dir.c
+++ b/crypto/x509/by_dir.c
@@ -310,11 +310,11 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
                 c = ent->dir[strlen(ent->dir) - 1];
                 if (c != ':' && c != '>' && c != ']') {
                     /*
-                    * If no separator is present, we assume the directory
-                    * specifier is a logical name, and add a colon.  We really
-                    * should use better VMS routines for merging things like
-                    * this, but this will do for now... -- Richard Levitte
-                    */
+                     * If no separator is present, we assume the directory
+                     * specifier is a logical name, and add a colon.  We really
+                     * should use better VMS routines for merging things like
+                     * this, but this will do for now... -- Richard Levitte
+                     */
                     c = ':';
                 } else {
                     c = '\0';
@@ -322,9 +322,9 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
 
                 if (c == '\0') {
                     /*
-                    * This is special.  When c == '\0', no directory separator
-                    * should be added.
-                    */
+                     * This is special.  When c == '\0', no directory separator
+                     * should be added.
+                     */
                     BIO_snprintf(b->data, b->max,
                                 "%s%08lx.%s%d", ent->dir, h, postfix, k);
                 } else
@@ -339,6 +339,7 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
     # endif
                 {
                     struct stat st;
+
                     if (stat(b->data, &st) < 0)
                         break;
                 }
@@ -357,11 +358,11 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
             }
 
             /*
-            * we have added it to the cache so now pull it out again
-            *
-            * Note: quadratic time find here since the objects won't generally be
-            *       sorted and sorting the would result in O(n^2 log n) complexity.
-            */
+             * we have added it to the cache so now pull it out again
+             *
+             * Note: quadratic time find here since the objects won't generally be
+             *       sorted and sorting the would result in O(n^2 log n) complexity.
+             */
             if (k > 0) {
                 if (!X509_STORE_lock(xl->store_ctx))
                     goto finish;
@@ -372,18 +373,18 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
                 tmp = NULL;
             }
             /*
-            * If a CRL, update the last file suffix added for this.
-            * We don't need to add an entry if k is 0 as this is the initial value.
-            * This avoids the need for a write lock and sort operation in the
-            * simple case where no CRL is present for a hash.
-            */
+             * If a CRL, update the last file suffix added for this.
+             * We don't need to add an entry if k is 0 as this is the initial value.
+             * This avoids the need for a write lock and sort operation in the
+             * simple case where no CRL is present for a hash.
+             */
             if (type == X509_LU_CRL && k > 0) {
                 if (!CRYPTO_THREAD_write_lock(ctx->lock))
                     goto finish;
                 /*
-                * Look for entry again in case another thread added an entry
-                * first.
-                */
+                 * Look for entry again in case another thread added an entry
+                 * first.
+                 */
                 if (hent == NULL) {
                     htmp.hash = h;
                     idx = sk_BY_DIR_HASH_find(ent->hashes, &htmp);
@@ -407,9 +408,9 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
                     }
 
                     /*
-                    * Ensure stack is sorted so that subsequent sk_BY_DIR_HASH_find
-                    * will not mutate the stack and therefore require a write lock.
-                    */
+                     * Ensure stack is sorted so that subsequent sk_BY_DIR_HASH_find
+                     * will not mutate the stack and therefore require a write lock.
+                     */
                     sk_BY_DIR_HASH_sort(ent->hashes);
                 } else if (hent->suffix < k) {
                     hent->suffix = k;
@@ -425,9 +426,9 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
                 memcpy(&ret->data, &tmp->data, sizeof(ret->data));
 
                 /*
-                * Clear any errors that might have been raised processing empty
-                * or malformed files.
-                */
+                 * Clear any errors that might have been raised processing empty
+                 * or malformed files.
+                 */
                 ERR_clear_error();
 
                 goto finish;

From 1301c593f88d5ea4d7087e72b42bd78bbfc2e344 Mon Sep 17 00:00:00 2001
From: Bruno de Lacheisserie <bruno.de.lacheisserie@gmail.com>
Date: Mon, 3 Jun 2024 12:34:29 +0200
Subject: [PATCH 5/6] test/recipes/60-test_x509_store_old.t : fix Copyright
 year

---
 test/recipes/60-test_x509_store_old.t | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/test/recipes/60-test_x509_store_old.t b/test/recipes/60-test_x509_store_old.t
index 6a00c9a448333..face5c7c0748c 100644
--- a/test/recipes/60-test_x509_store_old.t
+++ b/test/recipes/60-test_x509_store_old.t
@@ -1,5 +1,5 @@
 #! /usr/bin/env perl
-# Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved.
+# Copyright 2024 The OpenSSL Project Authors. All Rights Reserved.
 #
 # Licensed under the Apache License 2.0 (the "License").  You may not use
 # this file except in compliance with the License.  You can obtain a copy

From 4612aaf293430102137904d73096f496e642fe43 Mon Sep 17 00:00:00 2001
From: Bruno de Lacheisserie <bruno.de.lacheisserie@gmail.com>
Date: Mon, 3 Jun 2024 12:58:01 +0200
Subject: [PATCH 6/6] get_cert_by_subject_ex : don't use 0 hash value to
 indicate invalid hash

---
 crypto/x509/by_dir.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/crypto/x509/by_dir.c b/crypto/x509/by_dir.c
index 53debd2dabfbb..3ffe7e7b074de 100644
--- a/crypto/x509/by_dir.c
+++ b/crypto/x509/by_dir.c
@@ -231,6 +231,7 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
     int ok = 0;
     int i, j, k, l;
     unsigned long hash[2];
+    int valid_hash[2]; /* '0' for invalid value in `hash` array */
     unsigned long h;
     BUF_MEM *b = NULL;
     X509_OBJECT stmp, *tmp;
@@ -260,20 +261,18 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
     ctx = (BY_DIR *)xl->method_data;
 
     hash[0] = X509_NAME_hash_ex(name, libctx, propq, &l); /* SHA1 name hash */
-    if (l == 0) {
-        hash[0] = 0;
-    }
+    valid_hash[0] = (l != 0);
 #ifndef OPENSSL_NO_MD5    
     hash[1] = X509_NAME_hash_old(name); /* MD5 name hash */
+    valid_hash[1] = 1;
 #else
-    hash[1] = 0;
+    valid_hash[1] = 0;
 #endif
 
     for (l = 0; l < 2; ++l) {
         h = hash[l];
-        if (h == 0) {
+        if (valid_hash[l] == 0)
             continue; /* skip invalid hash */
-        }
 
         for (i = 0; i < sk_BY_DIR_ENTRY_num(ctx->dirs); i++) {
             BY_DIR_ENTRY *ent;
