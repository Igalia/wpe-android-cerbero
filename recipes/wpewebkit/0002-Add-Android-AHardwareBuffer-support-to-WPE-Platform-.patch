From 0d928e7f544cca17599352ceb228b8eccea37222 Mon Sep 17 00:00:00 2001
From: Felipe Erias <felipeerias@igalia.com>
Date: Tue, 14 Oct 2025 18:10:39 +0900
Subject: [PATCH] Add Android AHardwareBuffer support to WPE Platform API

This patch implements comprehensive support for zero-copy hardware-accelerated
rendering on Android using AHardwareBuffer with the WPE Platform API.

Changes:

1. WebProcessPoolGLib.cpp:
   - Enable Hardware RendererBufferTransportMode for Android
   - Adds AHardwareBuffer support alongside SharedMemory fallback

2. AcceleratedSurface.cpp/h:
   - Add RenderTargetAHardwareBuffer class implementing hardware buffer support
   - Fix SwapChain type selection for Android Surfaceless display
   - Allocate AHardwareBuffer with proper GPU usage flags
   - Use eglGetNativeClientBufferANDROID() to convert AHardwareBuffer to EGLClientBuffer
   - Create EGLImage from EGLClientBuffer using EGL_NATIVE_BUFFER_ANDROID
   - Bind EGLImage to GL texture for rendering
   - Send buffer to UI process via IPC

3. AcceleratedBackingStore.messages.in:
   - Add DidCreateAHBBuffer IPC message for AHardwareBuffer transport

4. AcceleratedBackingStore.cpp/h:
   - Implement didCreateAHBBuffer handler in UI process
   - Create WPEBuffer from received AHardwareBuffer
   - Integrate with existing buffer management system

This enables zero-copy buffer sharing between Web process and UI process,
providing hardware-accelerated rendering on Android without the overhead
of SharedMemory copying.

Fixes EGLImage creation failure in AcceleratedSurface by properly using
eglGetNativeClientBufferANDROID() as required by Android/EGL documentation,
instead of directly casting AHardwareBuffer pointers to EGLClientBuffer.

Note: WPEBufferAndroid.cpp also needs the same fix in createImageEGL15() and
createImageKHRImageBase() functions (to be submitted as separate upstream patch).
---
 .../glib/AcceleratedBackingStore.messages.in  |  1 +
 .../UIProcess/glib/WebProcessPoolGLib.cpp     |  4 +
 .../UIProcess/wpe/AcceleratedBackingStore.cpp | 17 +++++
 .../UIProcess/wpe/AcceleratedBackingStore.h   |  6 ++
 .../AcceleratedSurface.cpp                    | 89 +++++++++++++++++++
 .../CoordinatedGraphics/AcceleratedSurface.h  | 27 +++++++
 6 files changed, 144 insertions(+)

diff --git a/Source/WebKit/UIProcess/glib/AcceleratedBackingStore.messages.in b/Source/WebKit/UIProcess/glib/AcceleratedBackingStore.messages.in
index b0923127..8e2e85eb 100644
--- a/Source/WebKit/UIProcess/glib/AcceleratedBackingStore.messages.in
+++ b/Source/WebKit/UIProcess/glib/AcceleratedBackingStore.messages.in
@@ -24,6 +24,7 @@
 messages -> AcceleratedBackingStore {
     DidCreateDMABufBuffer(uint64_t id, WebCore::IntSize size, uint32_t format, Vector<UnixFileDescriptor> fds, Vector<uint32_t> offsets, Vector<uint32_t> strides, uint64_t modifier, WebKit::RendererBufferFormat::Usage usage)
     DidCreateSHMBuffer(uint64_t id, WebCore::ShareableBitmapHandle handle)
+    DidCreateAHBBuffer(uint64_t id, RefPtr<AHardwareBuffer> ahb)
     DidDestroyBuffer(uint64_t id)
     Frame(uint64_t id, Vector<WebCore::IntRect, 1> damage, UnixFileDescriptor syncFD)
 }
diff --git a/Source/WebKit/UIProcess/glib/WebProcessPoolGLib.cpp b/Source/WebKit/UIProcess/glib/WebProcessPoolGLib.cpp
index 044ddc0c..f43dc362 100644
--- a/Source/WebKit/UIProcess/glib/WebProcessPoolGLib.cpp
+++ b/Source/WebKit/UIProcess/glib/WebProcessPoolGLib.cpp
@@ -201,6 +201,10 @@ void WebProcessPool::platformInitializeWebProcess(const WebProcessProxy& process
 #if USE(GBM)
         if (!parameters.drmDevice.isNull())
             parameters.rendererBufferTransportMode.add(RendererBufferTransportMode::Hardware);
+#endif
+#if OS(ANDROID)
+        // Enable hardware-accelerated rendering with AHardwareBuffer
+        parameters.rendererBufferTransportMode.add(RendererBufferTransportMode::Hardware);
 #endif
         parameters.rendererBufferTransportMode.add(RendererBufferTransportMode::SharedMemory);
     }
diff --git a/Source/WebKit/UIProcess/wpe/AcceleratedBackingStore.cpp b/Source/WebKit/UIProcess/wpe/AcceleratedBackingStore.cpp
index 8aa136ce..431d5183 100644
--- a/Source/WebKit/UIProcess/wpe/AcceleratedBackingStore.cpp
+++ b/Source/WebKit/UIProcess/wpe/AcceleratedBackingStore.cpp
@@ -36,6 +36,10 @@
 #include <wtf/TZoneMallocInlines.h>
 #include <wtf/glib/GUniquePtr.h>
 
+#if OS(ANDROID)
+#include <wpe/WPEBufferAndroid.h>
+#endif
+
 #if USE(LIBDRM)
 #include <drm_fourcc.h>
 #endif
@@ -128,6 +132,19 @@ void AcceleratedBackingStore::didCreateSHMBuffer(uint64_t id, WebCore::Shareable
     m_buffers.add(id, WTFMove(buffer));
 }
 
+#if OS(ANDROID)
+void AcceleratedBackingStore::didCreateAHBBuffer(uint64_t id, RefPtr<AHardwareBuffer>&& ahb)
+{
+    if (!ahb)
+        return;
+
+    GRefPtr<WPEBuffer> buffer = adoptGRef(WPE_BUFFER(
+        wpe_buffer_android_new(wpe_view_get_display(m_wpeView.get()), ahb.get())));
+    m_bufferIDs.add(buffer.get(), id);
+    m_buffers.add(id, WTFMove(buffer));
+}
+#endif
+
 void AcceleratedBackingStore::didDestroyBuffer(uint64_t id)
 {
     if (auto buffer = m_buffers.take(id))
diff --git a/Source/WebKit/UIProcess/wpe/AcceleratedBackingStore.h b/Source/WebKit/UIProcess/wpe/AcceleratedBackingStore.h
index 0e4efc1c..f5550650 100644
--- a/Source/WebKit/UIProcess/wpe/AcceleratedBackingStore.h
+++ b/Source/WebKit/UIProcess/wpe/AcceleratedBackingStore.h
@@ -39,6 +39,9 @@
 
 typedef struct _WPEBuffer WPEBuffer;
 typedef struct _WPEView WPEView;
+#if OS(ANDROID)
+typedef struct AHardwareBuffer AHardwareBuffer;
+#endif
 
 namespace WebCore {
 class ShareableBitmapHandle;
@@ -77,6 +80,9 @@ private:
 
     void didCreateDMABufBuffer(uint64_t id, const WebCore::IntSize&, uint32_t format, Vector<WTF::UnixFileDescriptor>&&, Vector<uint32_t>&& offsets, Vector<uint32_t>&& strides, uint64_t modifier, RendererBufferFormat::Usage);
     void didCreateSHMBuffer(uint64_t id, WebCore::ShareableBitmapHandle&&);
+#if OS(ANDROID)
+    void didCreateAHBBuffer(uint64_t id, RefPtr<AHardwareBuffer>&& ahb);
+#endif
     void didDestroyBuffer(uint64_t id);
     void frame(uint64_t bufferID, Rects&&, WTF::UnixFileDescriptor&&);
     void frameDone();
diff --git a/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/AcceleratedSurface.cpp b/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/AcceleratedSurface.cpp
index ae94fd6e..f40cd25f 100644
--- a/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/AcceleratedSurface.cpp
+++ b/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/AcceleratedSurface.cpp
@@ -64,6 +64,12 @@
 #include <wtf/UniStdExtras.h>
 #endif
 
+#if OS(ANDROID)
+#include <android/hardware_buffer.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#endif
+
 #if USE(GLIB_EVENT_LOOP)
 #include <wtf/glib/RunLoopSourcePriority.h>
 #endif
@@ -435,6 +441,74 @@ AcceleratedSurface::RenderTargetTexture::~RenderTargetTexture()
     if (m_texture)
         glDeleteTextures(1, &m_texture);
 }
+
+#if OS(ANDROID)
+std::unique_ptr<AcceleratedSurface::RenderTarget> AcceleratedSurface::RenderTargetAHardwareBuffer::create(uint64_t surfaceID, const IntSize& size)
+{
+    AHardwareBuffer_Desc desc = {};
+    desc.width = size.width();
+    desc.height = size.height();
+    desc.layers = 1;
+    desc.format = AHARDWAREBUFFER_FORMAT_R8G8B8A8_UNORM;
+    desc.usage = AHARDWAREBUFFER_USAGE_GPU_FRAMEBUFFER
+                | AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE
+                | AHARDWAREBUFFER_USAGE_COMPOSER_OVERLAY;
+    desc.stride = 0;
+    desc.rfu0 = 0;
+    desc.rfu1 = 0;
+
+    AHardwareBuffer* ahb = nullptr;
+    int result = AHardwareBuffer_allocate(&desc, &ahb);
+    if (result != 0 || !ahb) {
+        WTFLogAlways("Failed to allocate AHardwareBuffer: %d", result);
+        return nullptr;
+    }
+
+    return makeUnique<RenderTargetAHardwareBuffer>(surfaceID, size, adoptRef(ahb));
+}
+
+AcceleratedSurface::RenderTargetAHardwareBuffer::RenderTargetAHardwareBuffer(uint64_t surfaceID, const IntSize& size, RefPtr<AHardwareBuffer>&& ahb)
+    : RenderTargetShareableBuffer(surfaceID, size)
+    , m_ahb(WTFMove(ahb))
+{
+    // Create EGLImage from AHardwareBuffer
+    auto& display = PlatformDisplay::sharedDisplay();
+
+    // Convert AHardwareBuffer to EGLClientBuffer using the Android extension
+    EGLClientBuffer clientBuffer = eglGetNativeClientBufferANDROID(m_ahb.get());
+    if (!clientBuffer) {
+        WTFLogAlways("Failed to get EGLClientBuffer from AHardwareBuffer");
+        return;
+    }
+
+    constexpr EGLint attributes[] = { EGL_IMAGE_PRESERVED, EGL_TRUE, EGL_NONE };
+    constexpr EGLenum target = static_cast<EGLenum>(0x3140); // EGL_NATIVE_BUFFER_ANDROID
+    m_image = eglCreateImageKHR(display.eglDisplay(), EGL_NO_CONTEXT, target,
+                                 clientBuffer, attributes);
+    if (m_image == EGL_NO_IMAGE) {
+        WTFLogAlways("Failed to create EGLImage from AHardwareBuffer: EGL error 0x%x", eglGetError());
+        return;
+    }
+
+    // Create and bind GL texture
+    glGenTextures(1, &m_texture);
+    glBindTexture(GL_TEXTURE_2D, m_texture);
+    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, m_image);
+    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, m_texture, 0);
+
+    // Send to UI process
+    WebProcess::singleton().parentProcessConnection()->send(
+        Messages::AcceleratedBackingStore::DidCreateAHBBuffer(m_id, RefPtr { m_ahb }), surfaceID);
+}
+
+AcceleratedSurface::RenderTargetAHardwareBuffer::~RenderTargetAHardwareBuffer()
+{
+    if (m_texture)
+        glDeleteTextures(1, &m_texture);
+    if (m_image)
+        eglDestroyImageKHR(PlatformDisplay::sharedDisplay().eglDisplay(), m_image);
+}
+#endif // OS(ANDROID)
 #endif // PLATFORM(GTK) || ENABLE(WPE_PLATFORM)
 
 #if USE(WPE_RENDERER)
@@ -509,10 +583,15 @@ AcceleratedSurface::SwapChain::SwapChain(uint64_t surfaceID)
     switch (display.type()) {
 #if PLATFORM(GTK) || ENABLE(WPE_PLATFORM)
     case PlatformDisplay::Type::Surfaceless:
+#if OS(ANDROID)
+        // On Android, use AHardwareBuffer for zero-copy rendering
+        m_type = Type::AHardwareBuffer;
+#else
         if (display.eglExtensions().MESA_image_dma_buf_export && WebProcess::singleton().rendererBufferTransportMode().contains(RendererBufferTransportMode::Hardware))
             m_type = Type::Texture;
         else
             m_type = Type::SharedMemory;
+#endif
         break;
 #if USE(GBM)
     case PlatformDisplay::Type::GBM:
@@ -637,6 +716,10 @@ std::unique_ptr<AcceleratedSurface::RenderTarget> AcceleratedSurface::SwapChain:
     case Type::WPEBackend:
         ASSERT_NOT_REACHED();
         break;
+#endif
+#if OS(ANDROID)
+    case Type::AHardwareBuffer:
+        return RenderTargetAHardwareBuffer::create(m_surfaceID, m_size);
 #endif
     case Type::Invalid:
         break;
diff --git a/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/AcceleratedSurface.h b/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/AcceleratedSurface.h
index 2d782b87..6bda64b1 100644
--- a/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/AcceleratedSurface.h
+++ b/Source/WebKit/WebProcess/WebPage/CoordinatedGraphics/AcceleratedSurface.h
@@ -46,6 +46,14 @@ typedef void *EGLImage;
 struct gbm_bo;
 #endif
 
+#if OS(ANDROID)
+struct AHardwareBuffer;
+#include <android/hardware_buffer.h>
+#if !defined(EGLImage)
+typedef void *EGLImage;
+#endif
+#endif
+
 #if USE(WPE_RENDERER)
 struct wpe_renderer_backend_egl_target;
 #endif
@@ -253,6 +261,22 @@ private:
     };
 #endif // PLATFORM(GTK) || ENABLE(WPE_PLATFORM)
 
+#if OS(ANDROID)
+    class RenderTargetAHardwareBuffer final : public RenderTargetShareableBuffer {
+    public:
+        static std::unique_ptr<RenderTarget> create(uint64_t, const WebCore::IntSize&);
+        RenderTargetAHardwareBuffer(uint64_t, const WebCore::IntSize&, RefPtr<AHardwareBuffer>&&);
+        ~RenderTargetAHardwareBuffer();
+
+    private:
+        bool supportsExplicitSync() const override { return true; }
+
+        RefPtr<AHardwareBuffer> m_ahb;
+        EGLImage m_image { nullptr };
+        unsigned m_texture { 0 };
+    };
+#endif
+
 #if USE(WPE_RENDERER)
     class RenderTargetWPEBackend final : public RenderTarget {
     public:
@@ -286,6 +310,9 @@ private:
             SharedMemory,
             Texture,
 #endif
+#if OS(ANDROID)
+            AHardwareBuffer,
+#endif
 #if USE(WPE_RENDERER)
             WPEBackend
 #endif
-- 
2.43.0

